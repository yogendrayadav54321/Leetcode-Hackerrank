
Problem 1--(ANAGRAM)


<!-- 

int anagram(string s) {
int n=s.length();
if(n%2!=0){
   return -1; 
}
string s1=s.substr(0,n/2);
string t=s.substr(n/2);
int m=t.length();
int count =0;
for(int i=0;i<m;i++){
    for(int j=0;j<m;j++){
        if(s[i]==t[j]){
          count++;
           
            t[j]='*';
            break;
        }
    }
}
return (m-count);
}


 -->

Problem 2--(Remove all occurences of duplicates in a linked list)


 <!-- 

 class Solution {
  public:
    Node* removeAllDuplicates(struct Node* head) {
        // code here
        if(head==NULL) return NULL;
        
    unordered_map<int ,int>mp;
    Node *temp=head;
    while(temp!=NULL){
        mp[temp->data]++;
        temp=temp->next;
    }
    
    Node* dummy=new Node(0);
    Node* tail=dummy;
    temp=head;
    
    
    while(temp){
        if(mp[temp->data]==1){
            tail->next=new Node(temp->data);
            tail=tail->next;
            
        }
        temp=temp->next;
    }
    return dummy->next;
    
    }
}; -->

Problem 3--(Print the Elements of a Linked List)

    <!----
    void printLinkedList(SinglyLinkedListNode* head) {
if(head==NULL){
    return;
}
SinglyLinkedListNode* p=head;
while(p!=NULL){
    printf("%d\n",p->data);
    p=p->next;
}

}
    
    -->

    Array insert at index
<!--
  class Solution {
  public:
    void insertAtIndex(vector<int> &arr, int index, int val) {
        // code here
        if(index>=0 && index<=arr.size()){
            arr.insert(arr.begin()+index,val);
        }
    }
};
  

-->

Who has the majority?
<!--
class Solution {
  public:
    int moreFrequent(vector<int>& arr, int x, int y) {
        // code here
        int count1=0;
        int count2=0;
        for(int i=0;i<arr.size();i++){
            if(arr[i]==x){
                count1++;
            }
            if(arr[i]==y){
                count2++;
            }
        }
        if(count1>count2){
            return x;
        }else if(count1==count2){
            if(x>y){
                return y;
            }else{
                return x;
            }
        }else{
            return y;
        }
        
    }
};

-->>

Value equal to index value


<!--
// User function template for C++

class Solution {
  public:
    // Function to find elements in the array that are equal to their index.
    vector<int> valueEqualToIndex(vector<int>& arr) {
        // code here
        vector<int>vec;
        for(int i=0;i<arr.size();i++){
            if(arr[i]==(i+1)){
                vec.push_back(i+1);
            }
        }
        return vec;
    }
};
-->>


14. Longest Common Prefix

<!--

class Solution {
public:
    string longestCommonPrefix(vector<string>& strs) {
        if(strs.empty()) return "";
    sort(strs.begin(),strs.end());
    string s1=strs[0];
    string s2=strs[strs.size()-1];
    int i=0;
while(i<s1.length()&& i<s2.length() && s1[i]==s2[i]){
    i++;
}
return s1.substr(0,i);

    }
};

-->>

88. Merge Sorted Array
<!--

class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        vector<int>vec1;
        vector<int>vec2;
        

        for(int i=0;i<m;i++){
            vec1.push_back(nums1[i]);
        }
        for(int i=0;i<n;i++){
            vec2.push_back(nums2[i]);
        }
        vec1.insert(vec1.end(),vec2.begin(),vec2.end());
        sort(vec1.begin(),vec1.end());
        for(int i=0;i<m+n;i++){
            nums1[i]=vec1[i];
        }

    }
};

-->
35. Search Insert Position
<!--
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        for(int i=0;i<nums.size();i++){
            if(nums[i]==target){
                return i;
            }
        }
       for( int i=0;i<nums.size();i++){
        if(nums[i]>target){
            return i;
        }}
        return nums.size();
       
    }
};

-->

16. 3Sum Closest

<!--

class Solution {
public:
    int threeSumClosest(vector<int>& nums, int target) {
         int closestSum = nums[0] + nums[1] + nums[2];
        int n=nums.size();
        for(int i=0;i<n-2;i++){
            for(int j=i+1;j<n-1;j++){
                for(int k=j+1;k<n;k++){
                    int sum=nums[i]+nums[j]+nums[k];
                    if (abs(target - sum) < abs(target - closestSum)) {
                        closestSum = sum;
                    }

                }
            }
        }
         return closestSum;
    }
};

-->


169. Majority Element

<!--



class Solution {
public:
    int majorityElement(vector<int>& nums) {
        map<int,int>freq;
        for(int i:nums){
            freq[i]++;
        }
        int maxFreq = 0;
    int maxElement = nums[0]; 
    for (auto &p : freq) {
        if (p.second > maxFreq) {
            maxFreq = p.second;
            maxElement = p.first;
        }
    }
return maxElement;

    }
};

-->

217. Contains Duplicate

<!--
class Solution {
public:
    bool containsDuplicate(vector<int>& nums) {
        map<int,int>freq;
        for(int i:nums){
            freq[i]++;
        }
for(auto &x:freq){
    if(x.second>1){
return true;
    }

}
return false;
    }
};

-->

Birthday Cake Candles
<!--
 int birthdayCakeCandles(vector<int> candles) {
sort(candles.begin(),candles.end());
int n=candles.size();
int max=candles[n-1];
int count =0;
for(int i=0;i<n;i++){
    if(candles[i]==max){
        count++;
    }
}
return count;

}


-->

CamelCase
<!--
int camelcase(string s) {
    int n=s.length();
    int count=1;
for(int i=0;i<n;i++){
    for(int j=65;j<91;j++){
        if(s[i]==j){
        count++;
    }
    }
    
}
     return count;
}

-->
